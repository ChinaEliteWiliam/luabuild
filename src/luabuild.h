/* this file is generated by gen_luabuild_h.lua, DO NOT MODIFY THIS! */
#ifndef luabuild_h
#define luabuild_h


#include <lua.h>
#include <lauxlib.h>


static int load_chunk(lua_State *L) {
  size_t bufflen = 12021;
  char buff[] = 
    "\nlocal USE_ONE = true\nlocal USE_VC = true\n\nlocal DEBUG = false\nloca"
    "l VERBOSE = false\nlocal info = {\n ROOT = [[..\\]];\n SRCDIR = [[..\\sr"
    "c\\]];\n DSTDIR = [[dstdir\\]];\n\n RM = 'del';\n CP = 'copy /y';\n QUIE"
    "T = ' 2>nul >&2';\n}\ninfo.gcc = {\n CC = 'gcc $CFLAGS $flags -c $input'"
    ";\n LD = 'gcc $CFLAGS $flags -o $output $input $libs';\n AR = 'ar rcs $o"
    "utput $input';\n RC = 'windres -i $input -o $RCOUT';\n RCOUT = '${output"
    "}.o';\n OBJ = '.o';\n}\ninfo.gcc_dbg = {\n base = info.gcc;\n CFLAGS = '"
    "-std=c99 -ggdb -pipe -O0 -Wall';\n}\ninfo.gcc_rel = {\n base = info.gcc;"
    "\n CFLAGS = '-std=c99 -s -pipe -O3 -Wall ';\n}\ninfo.vs = {\n CC = 'cl /"
    "nologo $CFLAGS $flags /c $input';\n LD = 'link /nologo $LDFLAGS $flags /"
    "OUT:\"$output\" $input $libs';\n AR = 'lib /nologo /OUT:$output $input';"
    "\n RC = 'rc /nologo /Fo\"$RCOUT\" $input';\n RCOUT = '${output}.res';\n "
    "OBJ = '.obj';\n}\ninfo.vs_dbg = {\n base = info.vs;\n CFLAGS = '/W3 /D_C"
    "RT_SECURE_NO_DEPRECATE '..\n '/MTd /Zi /Ob0 /Od /RTC1 /D _DEBUG';\n LDFL"
    "AGS = '/MACHINE:X86 /DEBUG /INCREMENTAL:NO /PDB:\"$output.pdb\"';\n}\nin"
    "fo.vs_rel = {\n base = info.vs;\n CFLAGS = '/nologo /W3 /D_CRT_SECURE_NO"
    "_DEPRECATE '..\n '/MT /O2 /Ob2 /D NDEBUG';\n LDFLAGS = '/MACHINE:X86 /IN"
    "CREMENTAL:NO';\n}\ninfo.vs_rel_pdb = {\n base = info.vs;\n CFLAGS = '/no"
    "logo /W3 /D_CRT_SECURE_NO_DEPRECATE '..\n '/MT /Zi /O2 /Ob1 /D NDEBUG';\n"
    " LDFLAGS = '/MACHINE:X86 /DEBUG /INCREMENTAL:NO /PDB:\"$output.pdb\"';\n"
    "}\ninfo.vs_rel_min = {\n base = info.vs;\n CFLAGS = '/nologo /W3 /D_CRT_"
    "SECURE_NO_DEPRECATE '..\n '/MT /O1 /Ob1 /D NDEBUG';\n LDFLAGS = '/MACHIN"
    "E:X86 /INCREMENTAL:NO';\n}\n\nlocal function find_version()\n local LUA_"
    "VERSION_MAJOR\n local LUA_VERSION_MINOR\n local LUA_VERSION_RELEASE\n lo"
    "cal LUA_COPYRIGHT\n local LUA_RELEASE\n\n io.input(info.SRCDIR .. \"lua."
    "h\")\n for line in io.lines() do\n local v = line:match \"#define%s+LUA_"
    "VERSION_MAJOR%s+\\\"(%d+)\\\"\"\n if v then LUA_VERSION_MAJOR = v goto n"
    "ext end\n local v = line:match \"#define%s+LUA_VERSION_MINOR%s+\\\"(%d+)"
    "\\\"\"\n if v then LUA_VERSION_MINOR = v goto next end\n local v = line:"
    "match \"#define%s+LUA_VERSION_RELEASE%s+\\\"(%d+)\\\"\"\n if v then LUA_"
    "VERSION_RELEASE = v goto next end\n local v = line:match \"#define%s+LUA"
    "_COPYRIGHT.-\\\"%s*(.-)\\\"\"\n if v then LUA_COPYRIGHT = v goto next en"
    "d\n local v = line:match \"#define%s+LUA_RELEASE%s+\\\"(.-)\\\"\"\n if v"
    " then LUA_RELEASE = tonumber(v) goto next end\n ::next::\n end\n io.inpu"
    "t():close()\n io.input(io.stdin)\n\n if not LUA_VERSION_MAJOR then\n ass"
    "ert(LUA_RELEASE, \"can not find Lua release!!\")\n LUA_VERSION_MAJOR,\n "
    "LUA_VERSION_MINOR,\n LUA_VERSION_RELEASE = LUA_RELEASE:match \"^Lua (%d+"
    ")%.(%d+)%.(%d+)\"\n assert(LUA_VERSION_MAJOR, \"can not find Lua release"
    "!!\")\n end\n print((\"find Lua release: Lua %d.%d.%d\\n%s\"):format(\n "
    "LUA_VERSION_MAJOR, LUA_VERSION_MINOR, LUA_VERSION_RELEASE,\n LUA_COPYRIG"
    "HT))\n info.LUA_VERSION_MAJOR = LUA_VERSION_MAJOR\n info.LUA_VERSION_MIN"
    "OR = LUA_VERSION_MINOR\n info.LUA_VERSION_RELEASE = LUA_VERSION_RELEASE\n"
    " info.LUA_COPYRIGHT = LUA_COPYRIGHT\n info.LUAV = LUA_VERSION_MAJOR..LUA"
    "_VERSION_MINOR\n info.LUA_RELEASE = (\"%d.%d.%d\"):format(\n LUA_VERSION"
    "_MAJOR,\n LUA_VERSION_MINOR,\n LUA_VERSION_RELEASE)\nend\n\nlocal functi"
    "on expand(s, t)\n local count = 0\n local function replace(s, space)\n l"
    "ocal s = t and t[s] or info[s]\n if s then\n if type(s) == \"table\" the"
    "n\n s = table.concat(s, \" \")\n end\n s = s .. (space or \"\")\n count "
    "= count + 1\n end\n return s or \"\"\n end\n assert(s, \"template expect"
    "ed\")\n while true do\n local old = count\n s = s:gsub(\"$%{([%w_]+)%}\""
    ", replace)\n s = s:gsub(\"$([%w_]+)(%s*)\", replace)\n if old == count t"
    "hen return s end\n end\nend\n\nlocal function patch_rcfile(file)\n local"
    " info = {\n LUA_CSV_RELEASE = (\"%d,%d,%d,0\"):format(\n info.LUA_VERSIO"
    "N_MAJOR,\n info.LUA_VERSION_MINOR,\n info.LUA_VERSION_RELEASE);\n }\n\n "
    "print(\"[PATCH]\\t\"..file..\".rc\")\n io.input(\"res/\"..file..\".rc\")"
    "\n io.output(file..\".rc\")\n\n for line in io.lines() do\n io.write(exp"
    "and(line, info), \"\\n\")\n end\n\n io.input():close()\n io.output():clo"
    "se()\n io.input(io.stdin)\n io.output(io.stdout)\nend\n\nlocal function "
    "patch_luaconf()\n local LUA_VDIR = info.LUA_VERSION_MAJOR..\".\"..info.L"
    "UA_VERSION_MINOR\n local t = {\n path = [[\n#define LUA_PATH_DEFAULT \"."
    "\\\\?.lua;\" \".\\\\?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"?.lua;\" LUA_CDI"
    "R \"?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"lua\\\\?.lua;\" LUA_CDIR \"lua\\"
    "\\?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"clibs\\\\?.lua;\" LUA_CDIR \"clibs"
    "\\\\?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"..\\\\share\\\\lua\\\\]]..LUA_VD"
    "IR..[[\\\\?.lua;\" \\\n\t\tLUA_CDIR \"..\\\\share\\\\lua\\\\]]..LUA_VDIR"
    "..[[\\\\?\\\\init.lua\"]];\n cpath = [[\n#define LUA_CPATH_DEFAULT \".\\"
    "\\?.dll;\" \".\\\\loadall.dll;\" \\\n\t\tLUA_CDIR \"?.dll;\" LUA_CDIR \""
    "loadall.dll;\" \\\n\t\tLUA_CDIR \"clibs\\\\?.dll;\" LUA_CDIR \"clibs\\\\"
    "loadall.dll;\" \\\n\t\tLUA_CDIR \"..\\\\lib\\\\lua\\\\]]..LUA_VDIR..[[\\"
    "\\?.dll;\" \\\n\t\tLUA_CDIR \"..\\\\lib\\\\lua\\\\]]..LUA_VDIR..[[\\\\lo"
    "adall.dll\"]];\n }\n\n print(\"[PATCH]\\tluaconf.h\")\n io.input(info.SR"
    "CDIR..\"luaconf.h\")\n io.output \"luaconf.h\"\n local patched = 0\n loc"
    "al begin\n for line in io.lines() do\n if patched < 2 then\n if begin an"
    "d not line:match \"\\\\$\" then\n line = t[begin]\n patched = patched + "
    "1\n begin = nil\n elseif line:match \"#define%s+LUA_PATH_DEFAULT\" then\n"
    " begin = \"path\"\n elseif line:match \"#define%s+LUA_CPATH_DEFAULT\" th"
    "en\n begin = \"cpath\"\n end\n end\n\n if not begin then io.write(line, "
    "\"\\n\") end\n end\n io.input():close()\n io.output():close()\n io.input"
    "(io.stdin)\n io.output(io.stdout)\nend\n\nlocal function glob(pattern)\n"
    " local fh = assert(io.popen(\"DIR /B /W \"..pattern))\n local files = {}"
    "\n for line in fh:lines() do\n files[#files+1] = line\n end\n fh:close()"
    "\n return files\nend\n\nlocal function map(files, f)\n local t = {}\n fo"
    "r i, v in ipairs(files) do\n local new = f(i, v)\n if new then t[#t+1] ="
    " new end\n end\n return t\nend\n\nlocal function tsub(files, pattern, re"
    "place)\n local t = {}\n for i, v in ipairs(files) do\n t[i] = v:gsub(pat"
    "tern, replace)\n end\n return t\nend\n\nlocal function execute(fmt, t)\n"
    " local cmdline = expand(fmt, t)\n if VERBOSE then\n print(\">>\", cmdlin"
    "e)\n end\n return assert(os.execute(cmdline))\nend\n\nlocal function fin"
    "d_toolchain(toolchain)\n if not toolchain then\n --local env = os.getenv"
    " \"VS120COMNTOOLS\" or -- VS2013\n --os.getenv \"VS110COMNTOOLS\" or -- "
    "VS2012\n --os.getenv \"VS100COMNTOOLS\" or -- VS2010\n --os.getenv \"VS9"
    "0COMNTOOLS\" -- VS2008\n --if env then\n --execute(\"call \"..env..\"vsv"
    "ars32.bat\")\n --end\n if execute[[cl $QUIET]] then\n print(\"find VS to"
    "olchain\")\n toolchain = \"vs\"\n elseif execute[[gcc --version $QUIET]]"
    " then\n print(\"find GCC toolchain\")\n toolchain = \"gcc\"\n end\n if n"
    "ot toolchain then\n print(\"can not find toolchain!!!\")\n end\n toolcha"
    "in = toolchain .. (DEBUG and \"_dbg\" or \"_rel\")\n end\n print(\"use t"
    "oolchain: \"..toolchain)\n info.TOOLCHAIN = toolchain\n local t = info[t"
    "oolchain]\n repeat\n for k,v in pairs(t) do\n info[k] = v\n end\n t = t."
    "base\n until not t\nend\n\nlocal function compile(file, flags)\n if type"
    "(file) == \"string\" then\n print(\"[CC]\\t\"..file)\n end\n return exec"
    "ute(\"$CC\", {\n input = file,\n flags = flags,\n })\nend\n\nlocal funct"
    "ion compile_rc(file)\n print(\"[RC]\\t\"..file)\n local t = {\n input = "
    "file,\n output = file,\n }\n if execute(info.RC, t) then\n return expand"
    "(info.RCOUT, t)\n end\nend\n\nlocal function link(target, files, flags, "
    "libs)\n print(\"[LINK]\\t\"..target)\n return execute(info.LD, {\n flags"
    " = flags,\n input = files,\n output = target,\n libs = libs,\n })\nend\n"
    "\nlocal function library(lib, files)\n print(\"[AR]\\t\"..lib)\n return "
    "execute(info.AR, {\n output = lib,\n input = files,\n })\nend\n\nlocal f"
    "unction buildone_luas()\n patch_rcfile \"luas\"\n local LUAV = info.LUAV"
    "\n local rc = compile_rc \"luas.rc\"\n local flags = { \"-DLUA_BUILD_AS_"
    "DLL -DMAKE_LUA -I$SRCDIR\" }\n local ldflags = {}\n if tonumber(LUAV) >="
    " 53 then\n flags[#flags+1] = \"-DHAVE_LPREFIX\"\n end\n if info.TOOLCHAI"
    "N:match \"^gcc\" then\n ldflags[#ldflags+1] = \"-Wl,--out-implib,liblua\""
    "..LUAV..\".exe.a\"\n end\n compile(\"one.c\", flags)\n link(\"lua\"..LUA"
    "V..\".exe\", \"one$OBJ \"..rc, ldflags)\n if info.TOOLCHAIN:match \"^vs\""
    " then\n execute[[move /Y lua${LUAV}.lib lua${LUAV}exe.lib $QUIET]]\n exe"
    "cute[[move /Y lua${LUAV}.exp lua${LUAV}exe.exp $QUIET]]\n end\nend\n\nlo"
    "cal function buildone_luadll()\n patch_rcfile \"luadll\"\n local LUAV = "
    "info.LUAV\n local rc = compile_rc \"luadll.rc\"\n local flags = { \"-DLU"
    "A_BUILD_AS_DLL -DMAKE_LIB -I$SRCDIR\" }\n local ldflags = {}\n if tonumb"
    "er(LUAV) >= 53 then\n flags[#flags+1] = \"-DHAVE_LPREFIX\"\n end\n if in"
    "fo.TOOLCHAIN:match \"^gcc\" then\n ldflags[#ldflags+1] = \"-mdll\"\n ldf"
    "lags[#ldflags+1] = \"-Wl,--out-implib,liblua\"..LUAV..\".dll.a\"\n ldfla"
    "gs[#ldflags+1] = \"-Wl,--output-def,lua\"..LUAV..\".def\"\n else\n ldfla"
    "gs[#ldflags+1] = \"/DLL\"\n end\n compile(\"one.c \", flags)\n link(\"lu"
    "a\"..LUAV..\".dll\", \"one$OBJ \"..rc, ldflags)\nend\n\nlocal function b"
    "uild_lua()\n patch_rcfile \"lua\"\n local LUAV = info.LUAV\n local rc = "
    "compile_rc \"lua.rc\"\n local flags = \"-DLUA_BUILD_AS_DLL -I$SRCDIR\"\n"
    " local libs\n if info.TOOLCHAIN:match \"^gcc\" then\n libs = \"-L. -llua"
    "\"..LUAV..\".dll\"\n else\n libs = \"lua\"..LUAV..\".lib\"\n end\n compi"
    "le(\"lua.c \", flags)\n link(\"lua.exe\", \"lua$OBJ \"..rc, nil, libs)\n"
    "end\n\nlocal function buildone_luac()\n patch_rcfile \"luac\"\n local LU"
    "AV = info.LUAV\n local rc = compile_rc \"luac.rc\"\n local flags = \"-DM"
    "AKE_LUAC -I$SRCDIR\"\n if tonumber(LUAV) >= 53 then\n flags = flags .. \""
    " -DHAVE_LPREFIX\"\n end\n compile(\"one.c \", flags)\n link(\"luac.exe\""
    ", \"one$OBJ \"..rc)\nend\n\nlocal function build_lualib()\n print(\"[CC]"
    "\\tlualib\")\n local files = map(glob(info.SRCDIR..\"*.c\"), function(i,"
    " v)\n if v ~= \"lua.c\" and v ~= \"luac.c\" then\n return info.SRCDIR .."
    " v\n end\n end)\n local LUAV = info.LUAV\n compile(files, \"-DLUA_BUILD_"
    "AS_DLL -I$SRCDIR\")\n if info.TOOLCHAIN:match \"^gcc\" then\n library(\""
    "liblua\"..LUAV..\".a\",\n tsub(files, info.SRCDIR..\"(.*).c$\", \"%1.o\""
    "))\n else\n library(\"lua\"..LUAV..\"s.lib\",\n tsub(files, info.SRCDIR."
    ".\"(.*).c$\", \"%1.obj\"))\n end\n execute(\"$RM /s /q *.o *.obj $QUIET\""
    ")\nend\n\nlocal function make_dirs()\n print(\"[MKDIR]\\t\"..info.DSTDIR"
    ")\n execute [[del /s /q $DSTDIR $QUIET]]\n execute [[mkdir ${DSTDIR} $QU"
    "IET]]\n execute [[mkdir ${DSTDIR}clibs $QUIET]]\n execute [[mkdir ${DSTD"
    "IR}doc $QUIET]]\n execute [[mkdir ${DSTDIR}lua $QUIET]]\n execute [[mkdi"
    "r ${DSTDIR}include $QUIET]]\n execute [[mkdir ${DSTDIR}lib $QUIET]]\nend"
    "\n\nlocal function install_doc()\n print(\"[INSTALL]\\tdocuments\")\n fo"
    "r i, v in ipairs(glob(info.ROOT..\"doc\")) do\n execute([[$CP ${ROOT}doc"
    "\\$output ${DSTDIR}doc $QUIET]], { output = v })\n end\nend\n\nlocal fun"
    "ction install_headers()\n print \"[INSTALL]\\theaders\"\n execute[[$CP $"
    "{SRCDIR}luaconf.h ${DSTDIR}include $QUIET]]\n execute[[$CP ${SRCDIR}lua."
    "h ${DSTDIR}include $QUIET]]\n execute[[$CP ${SRCDIR}lua.hpp ${DSTDIR}inc"
    "lude $QUIET]]\n execute[[$CP ${SRCDIR}lauxlib.h ${DSTDIR}include $QUIET]"
    "]\n execute[[$CP ${SRCDIR}lualib.h ${DSTDIR}include $QUIET]]\nend\n\nloc"
    "al function install_executables()\n print \"[INSTALL]\\texecutables\"\n "
    "execute[[$CP *.exe $DSTDIR $QUIET]]\n execute[[$CP *.dll $DSTDIR $QUIET]"
    "]\n execute[[$RM vc*.pdb]]\n execute[[$CP *.pdb $DSTDIR $QUIET]]\nend\n\n"
    "local function install_libraries()\n print \"[INSTALL]\\tlibraries\"\n e"
    "xecute[[$CP *.a ${DSTDIR}lib $QUIET]]\n execute[[$CP *.lib ${DSTDIR}lib "
    "$QUIET]]\n execute[[$CP *.def ${DSTDIR}lib $QUIET]]\n execute[[$CP *.exp"
    " ${DSTDIR}lib $QUIET]]\nend\n\nlocal function install()\n assert = funct"
    "ion(...) return ... end\n info.DSTDIR = expand[[Lua$LUAV$TOOLCHAIN\\]]\n"
    " print(\"[INSTALL]\\t\"..info.DSTDIR)\n make_dirs()\n install_doc()\n in"
    "stall_headers()\n install_executables()\n install_libraries()\nend\n\nlo"
    "cal function cleanup()\n print(\"[CLEANUP]\")\n execute[[$RM *.def *.a *"
    ".exe *.dll *.rc *.o $QUIET]]\n execute[[$RM *.obj *.lib *.exp *.res *.pd"
    "b *.ilk *.idb $QUIET]]\n execute[[$RM luaconf.h $QUIET]]\nend\n\n-- begi"
    "n build\nwhile arg[1] and arg[1]:sub(1,1) == '-' do\n if arg[1] == '-v' "
    "then\n VERBOSE = true\n elseif arg[1] == '-d' then\n DEBUG = true\n else"
    "if arg[1] == '-h' or arg[1] == '-?' then\n print(arg[0]..\" [-v] [-d] [t"
    "oolchain]\")\n print(\"support toolchain:\")\n local tls = {}\n for k,v "
    "in pairs(info) do\n if type(v) == 'table' and v.base then\n tls[#tls+1] "
    "= k\n end\n end\n table.sort(tls)\n print(\" \"..table.concat(tls, \"\\n"
    " \"))\n return\n end\n table.remove(arg, 1)\nend\n\nfind_version()\npatc"
    "h_luaconf()\n\nfind_toolchain(arg[1])\nbuildone_luas()\nbuildone_luadll("
    ")\nbuild_lua()\nbuildone_luac()\nbuild_lualib()\ninstall()\ncleanup()\np"
    "rint \"[DONE]\"\n\n-- cc: cc='D:\\lua53\\lua.exe'\n"
;

  return luaL_loadbuffer(L, buff, bufflen, "=luabuild.lua");
}


#endif /* luabuild_h */
