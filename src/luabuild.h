/* this file is generated by gen_luabuild_h.lua, DO NOT MODIFY THIS! */
#ifndef luabuild_h
#define luabuild_h


#include <lua.h>
#include <lauxlib.h>


static int load_chunk(lua_State *L) {
  size_t bufflen = 12371;
  char buff[] = 
    "\nlocal USE_ONE = true\nlocal USE_VC = true\n\nlocal DEBUG = false\nloca"
    "l VERBOSE = false\nlocal info = {\n ROOT = [[..\\]];\n SRCDIR = [[..\\sr"
    "c\\]];\n DSTDIR = [[dstdir\\]];\n\n RM = 'del';\n CP = 'copy /y';\n QUIE"
    "T = ' >nul 2>nul';\n}\ninfo.gcc = {\n CC = 'gcc $CFLAGS $flags -c $input"
    "';\n LD = 'gcc $CFLAGS $flags -o $output $input $libs';\n AR = 'ar rcs $"
    "output $input';\n RC = 'windres -i $input -o $RCOUT';\n RCOUT = '${outpu"
    "t}.o';\n OBJ = '.o';\n}\ninfo.gcc_dbg = {\n base = info.gcc;\n CFLAGS = "
    "'-std=c99 -ggdb -pipe -O0 -Wall';\n}\ninfo.gcc_rel = {\n base = info.gcc"
    ";\n CFLAGS = '-std=c99 -s -pipe -O3 -Wall ';\n}\ninfo.vs = {\n CC = 'cl "
    "/nologo $CFLAGS $flags /c $input';\n LD = 'link /nologo $LDFLAGS $flags "
    "/OUT:\"$output\" $input $libs';\n AR = 'lib /nologo /OUT:$output $input'"
    ";\n RC = 'rc /nologo /Fo\"$RCOUT\" $input';\n RCOUT = '${output}.res';\n"
    " OBJ = '.obj';\n}\ninfo.vs_dbg = {\n base = info.vs;\n CFLAGS = '/W3 /D_"
    "CRT_SECURE_NO_DEPRECATE '..\n '/MTd /Zi /Ob0 /Od /RTC1 /D _DEBUG';\n LDF"
    "LAGS = '/MACHINE:X86 /DEBUG /INCREMENTAL:NO /PDB:\"$output.pdb\"';\n}\ni"
    "nfo.vs_rel = {\n base = info.vs;\n CFLAGS = '/nologo /W3 /D_CRT_SECURE_N"
    "O_DEPRECATE '..\n '/MT /GS- /GL /Gy /Oy- /O2 /Oi /arch:SSE2 /DNDEBUG';\n"
    " LDFLAGS = '/OPT:REF /OPT:ICF /MACHINE:X86 /INCREMENTAL:NO /LTCG:increme"
    "ntal';\n}\ninfo.vs_rel_pdb = {\n base = info.vs;\n CFLAGS = '/nologo /W3"
    " /D_CRT_SECURE_NO_DEPRECATE '..\n '/MT /GS- /GL /Gy /Oy- /O2 /Oi /Zi /ar"
    "ch:SSE2 /DNDEBUG';\n LDFLAGS = '/OPT:REF /OPT:ICF /MACHINE:X86 /INCREMEN"
    "TAL:NO /LTCG:incremental /DEBUG:FASTLINK /PDB:\"$output.pdb\"';\n}\ninfo"
    ".vs_rel_min = {\n base = info.vs;\n CFLAGS = '/nologo /W3 /D_CRT_SECURE_"
    "NO_DEPRECATE '..\n '/MT /GS- /GL /Gy /O1 /Ob1 /Oi /Oy- /arch:SSE2 /DNDEB"
    "UG';\n LDFLAGS = '/OPT:REF /OPT:ICF /MACHINE:X86 /INCREMENTAL:NO /LTCG:i"
    "ncremental';\n}\n\nlocal function find_version()\n local LUA_VERSION_MAJ"
    "OR\n local LUA_VERSION_MINOR\n local LUA_VERSION_RELEASE\n local LUA_COP"
    "YRIGHT\n local LUA_RELEASE\n\n io.input(info.SRCDIR .. \"lua.h\")\n for "
    "line in io.lines() do\n local v = line:match \"#define%s+LUA_VERSION_MAJ"
    "OR%s+\\\"(%d+)\\\"\"\n if v then LUA_VERSION_MAJOR = v goto next end\n l"
    "ocal v = line:match \"#define%s+LUA_VERSION_MINOR%s+\\\"(%d+)\\\"\"\n if"
    " v then LUA_VERSION_MINOR = v goto next end\n local v = line:match \"#de"
    "fine%s+LUA_VERSION_RELEASE%s+\\\"(%d+)\\\"\"\n if v then LUA_VERSION_REL"
    "EASE = v goto next end\n local v = line:match \"#define%s+LUA_COPYRIGHT."
    "-\\\"%s*(.-)\\\"\"\n if v then LUA_COPYRIGHT = v goto next end\n local v"
    " = line:match \"#define%s+LUA_RELEASE%s+\\\"(.-)\\\"\"\n if v then LUA_R"
    "ELEASE = tonumber(v) goto next end\n ::next::\n end\n io.input():close()"
    "\n io.input(io.stdin)\n\n if not LUA_VERSION_MAJOR then\n assert(LUA_REL"
    "EASE, \"can not find Lua release!!\")\n LUA_VERSION_MAJOR,\n LUA_VERSION"
    "_MINOR,\n LUA_VERSION_RELEASE = LUA_RELEASE:match \"^Lua (%d+)%.(%d+)%.("
    "%d+)\"\n assert(LUA_VERSION_MAJOR, \"can not find Lua release!!\")\n end"
    "\n print((\"find Lua release: Lua %d.%d.%d\\n%s\"):format(\n LUA_VERSION"
    "_MAJOR, LUA_VERSION_MINOR, LUA_VERSION_RELEASE,\n LUA_COPYRIGHT))\n info"
    ".LUA_VERSION_MAJOR = LUA_VERSION_MAJOR\n info.LUA_VERSION_MINOR = LUA_VE"
    "RSION_MINOR\n info.LUA_VERSION_RELEASE = LUA_VERSION_RELEASE\n info.LUA_"
    "COPYRIGHT = LUA_COPYRIGHT\n info.LUAV = LUA_VERSION_MAJOR..LUA_VERSION_M"
    "INOR\n info.LUA_RELEASE = (\"%d.%d.%d\"):format(\n LUA_VERSION_MAJOR,\n "
    "LUA_VERSION_MINOR,\n LUA_VERSION_RELEASE)\nend\n\nlocal function expand("
    "s, t)\n local count = 0\n local function replace(s, space)\n local s = t"
    " and t[s] or info[s]\n if s then\n if type(s) == \"table\" then\n s = ta"
    "ble.concat(s, \" \")\n end\n s = s .. (space or \"\")\n count = count + "
    "1\n end\n return s or \"\"\n end\n assert(s, \"template expected\")\n wh"
    "ile true do\n local old = count\n s = s:gsub(\"$%{([%w_]+)%}\", replace)"
    "\n s = s:gsub(\"$([%w_]+)(%s*)\", replace)\n if old == count then return"
    " s end\n end\nend\n\nlocal function patch_rcfile(file)\n local info = {\n"
    " LUA_CSV_RELEASE = (\"%d,%d,%d,0\"):format(\n info.LUA_VERSION_MAJOR,\n "
    "info.LUA_VERSION_MINOR,\n info.LUA_VERSION_RELEASE);\n }\n\n print(\"[PA"
    "TCH]\\t\"..file..\".rc\")\n io.input(\"res/\"..file..\".rc\")\n io.outpu"
    "t(file..\".rc\")\n\n for line in io.lines() do\n io.write(expand(line, i"
    "nfo), \"\\n\")\n end\n\n io.input():close()\n io.output():close()\n io.i"
    "nput(io.stdin)\n io.output(io.stdout)\nend\n\nlocal function patch_luaco"
    "nf()\n local LUA_VDIR = info.LUA_VERSION_MAJOR..\".\"..info.LUA_VERSION_"
    "MINOR\n local t = {\n path = [[\n#define LUA_PATH_DEFAULT \".\\\\?.lua;\""
    " \".\\\\?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"?.lua;\" LUA_CDIR \"?\\\\ini"
    "t.lua;\" \\\n\t\tLUA_CDIR \"lua\\\\?.lua;\" LUA_CDIR \"lua\\\\?\\\\init."
    "lua;\" \\\n\t\tLUA_CDIR \"clibs\\\\?.lua;\" LUA_CDIR \"clibs\\\\?\\\\ini"
    "t.lua;\" \\\n\t\tLUA_CDIR \"..\\\\share\\\\lua\\\\]]..LUA_VDIR..[[\\\\?."
    "lua;\" \\\n\t\tLUA_CDIR \"..\\\\share\\\\lua\\\\]]..LUA_VDIR..[[\\\\?\\\\"
    "init.lua\"]];\n cpath = [[\n#define LUA_CPATH_DEFAULT \".\\\\?.dll;\" \""
    ".\\\\loadall.dll;\" \\\n\t\tLUA_CDIR \"?.dll;\" LUA_CDIR \"loadall.dll;\""
    " \\\n\t\tLUA_CDIR \"clibs\\\\?.dll;\" LUA_CDIR \"clibs\\\\loadall.dll;\""
    " \\\n\t\tLUA_CDIR \"..\\\\lib\\\\lua\\\\]]..LUA_VDIR..[[\\\\?.dll;\" \\\n"
    "\t\tLUA_CDIR \"..\\\\lib\\\\lua\\\\]]..LUA_VDIR..[[\\\\loadall.dll\"]];\n"
    " }\n\n print(\"[PATCH]\\tluaconf.h\")\n io.input(info.SRCDIR..\"luaconf."
    "h\")\n io.output \"luaconf.h\"\n local patched = 0\n local begin\n for l"
    "ine in io.lines() do\n if patched < 2 then\n if begin and not line:match"
    " \"\\\\$\" then\n line = t[begin]\n patched = patched + 1\n begin = nil\n"
    " elseif line:match \"#define%s+LUA_PATH_DEFAULT\" then\n begin = \"path\""
    "\n elseif line:match \"#define%s+LUA_CPATH_DEFAULT\" then\n begin = \"cp"
    "ath\"\n end\n end\n\n if not begin then io.write(line, \"\\n\") end\n en"
    "d\n io.input():close()\n io.output():close()\n io.input(io.stdin)\n io.o"
    "utput(io.stdout)\nend\n\nlocal function glob(pattern)\n local fh = asser"
    "t(io.popen(\"DIR /B /W \"..pattern))\n local files = {}\n for line in fh"
    ":lines() do\n files[#files+1] = line\n end\n fh:close()\n return files\n"
    "end\n\nlocal function map(files, f)\n local t = {}\n for i, v in ipairs("
    "files) do\n local new = f(i, v)\n if new then t[#t+1] = new end\n end\n "
    "return t\nend\n\nlocal function tsub(files, pattern, replace)\n local t "
    "= {}\n for i, v in ipairs(files) do\n t[i] = v:gsub(pattern, replace)\n "
    "end\n return t\nend\n\nlocal function execute(fmt, t)\n local cmdline = "
    "expand(fmt, t)\n if VERBOSE then\n print(\">>\", cmdline)\n end\n return"
    " assert(os.execute(cmdline))\nend\n\nlocal function find_toolchain(toolc"
    "hain)\n if not toolchain then\n --local env = os.getenv \"VS120COMNTOOLS"
    "\" or -- VS2013\n --os.getenv \"VS110COMNTOOLS\" or -- VS2012\n --os.get"
    "env \"VS100COMNTOOLS\" or -- VS2010\n --os.getenv \"VS90COMNTOOLS\" -- V"
    "S2008\n --if env then\n --execute(\"call \"..env..\"vsvars32.bat\")\n --"
    "end\n if os.execute(expand[[cl $QUIET]]) then\n print(\"find VS toolchai"
    "n\")\n toolchain = \"vs\"\n elseif os.execute(expand[[gcc --version $QUI"
    "ET]]) then\n print(\"find GCC toolchain\")\n toolchain = \"gcc\"\n end\n"
    " if not toolchain then\n print(\"can not find toolchain!!!\")\n end\n to"
    "olchain = toolchain .. (DEBUG and \"_dbg\" or \"_rel\")\n end\n print(\""
    "use toolchain: \"..toolchain)\n info.TOOLCHAIN = toolchain\n local t = i"
    "nfo[toolchain]\n repeat\n for k,v in pairs(t) do\n info[k] = v\n end\n t"
    " = t.base\n until not t\nend\n\nlocal function compile(file, flags)\n if"
    " type(file) == \"string\" then\n print(\"[CC]\\t\"..file)\n end\n return"
    " execute(\"$CC\", {\n input = file,\n flags = flags,\n })\nend\n\nlocal "
    "function compile_rc(file)\n print(\"[RC]\\t\"..file)\n local t = {\n inp"
    "ut = file,\n output = file,\n }\n if execute(info.RC, t) then\n return e"
    "xpand(info.RCOUT, t)\n end\nend\n\nlocal function link(target, files, fl"
    "ags, libs)\n print(\"[LINK]\\t\"..target)\n return execute(info.LD, {\n "
    "flags = flags,\n input = files,\n output = target,\n libs = libs,\n })\n"
    "end\n\nlocal function library(lib, files)\n print(\"[AR]\\t\"..lib)\n re"
    "turn execute(info.AR, {\n output = lib,\n input = files,\n })\nend\n\nlo"
    "cal function buildone_luas()\n patch_rcfile \"luas\"\n local LUAV = info"
    ".LUAV\n local rc = compile_rc \"luas.rc\"\n local flags = { \"-DLUA_BUIL"
    "D_AS_DLL -DMAKE_LUA -I$SRCDIR\" }\n local ldflags = {}\n if tonumber(LUA"
    "V) >= 53 then\n flags[#flags+1] = \"-DHAVE_LPREFIX\"\n end\n if info.TOO"
    "LCHAIN:match \"^gcc\" then\n ldflags[#ldflags+1] = \"-Wl,--out-implib,li"
    "blua\"..LUAV..\".exe.a\"\n end\n compile(\"one.c\", flags)\n link(\"lua\""
    "..LUAV..\".exe\", \"one$OBJ \"..rc, ldflags)\n if info.TOOLCHAIN:match \""
    "^vs\" then\n execute[[move /Y lua${LUAV}.lib lua${LUAV}exe.lib $QUIET]]\n"
    " execute[[move /Y lua${LUAV}.exp lua${LUAV}exe.exp $QUIET]]\n end\nend\n"
    "\nlocal function buildone_luadll()\n patch_rcfile \"luadll\"\n local LUA"
    "V = info.LUAV\n local rc = compile_rc \"luadll.rc\"\n local flags = { \""
    "-DLUA_BUILD_AS_DLL -DMAKE_LIB -I$SRCDIR\" }\n local ldflags = {}\n if to"
    "number(LUAV) >= 53 then\n flags[#flags+1] = \"-DHAVE_LPREFIX\"\n end\n i"
    "f info.TOOLCHAIN:match \"^gcc\" then\n ldflags[#ldflags+1] = \"-mdll\"\n"
    " ldflags[#ldflags+1] = \"-Wl,--out-implib,liblua\"..LUAV..\".dll.a\"\n l"
    "dflags[#ldflags+1] = \"-Wl,--output-def,lua\"..LUAV..\".def\"\n else\n l"
    "dflags[#ldflags+1] = \"/DLL\"\n end\n compile(\"one.c \", flags)\n link("
    "\"lua\"..LUAV..\".dll\", \"one$OBJ \"..rc, ldflags)\nend\n\nlocal functi"
    "on build_lua()\n patch_rcfile \"lua\"\n local LUAV = info.LUAV\n local r"
    "c = compile_rc \"lua.rc\"\n local flags = \"-DLUA_BUILD_AS_DLL -I$SRCDIR"
    "\"\n local libs\n if info.TOOLCHAIN:match \"^gcc\" then\n libs = \"-L. -"
    "llua\"..LUAV..\".dll\"\n else\n libs = \"lua\"..LUAV..\".lib\"\n end\n c"
    "ompile(\"lua.c \", flags)\n link(\"lua.exe\", \"lua$OBJ \"..rc, nil, lib"
    "s)\nend\n\nlocal function buildone_luac()\n patch_rcfile \"luac\"\n loca"
    "l LUAV = info.LUAV\n local rc = compile_rc \"luac.rc\"\n local flags = \""
    "-DMAKE_LUAC -I$SRCDIR\"\n if tonumber(LUAV) >= 53 then\n flags = flags ."
    ". \" -DHAVE_LPREFIX\"\n end\n compile(\"one.c \", flags)\n link(\"luac.e"
    "xe\", \"one$OBJ \"..rc)\nend\n\nlocal function build_lualib()\n print(\""
    "[CC]\\tlualib\")\n local files = map(glob(info.SRCDIR..\"*.c\"), functio"
    "n(i, v)\n if v ~= \"lua.c\" and v ~= \"luac.c\" then\n return info.SRCDI"
    "R .. v\n end\n end)\n local LUAV = info.LUAV\n compile(files, \"-DLUA_BU"
    "ILD_AS_DLL -I$SRCDIR\")\n if info.TOOLCHAIN:match \"^gcc\" then\n librar"
    "y(\"liblua\"..LUAV..\".a\",\n tsub(files, info.SRCDIR..\"(.*).c$\", \"%1"
    ".o\"))\n else\n library(\"lua\"..LUAV..\"s.lib\",\n tsub(files, info.SRC"
    "DIR..\"(.*).c$\", \"%1.obj\"))\n end\n execute(\"$RM /s /q *.o *.obj $QU"
    "IET\")\nend\n\nlocal function make_dirs()\n print(\"[MKDIR]\\t\"..info.D"
    "STDIR)\n execute [[del /s /q $DSTDIR $QUIET]]\n execute [[mkdir ${DSTDIR"
    "} $QUIET]]\n execute [[mkdir ${DSTDIR}clibs $QUIET]]\n execute [[mkdir $"
    "{DSTDIR}doc $QUIET]]\n execute [[mkdir ${DSTDIR}lua $QUIET]]\n execute ["
    "[mkdir ${DSTDIR}include $QUIET]]\n execute [[mkdir ${DSTDIR}lib $QUIET]]"
    "\nend\n\nlocal function install_doc()\n print(\"[INSTALL]\\tdocuments\")"
    "\n for i, v in ipairs(glob(info.ROOT..\"doc\")) do\n execute([[$CP ${ROO"
    "T}doc\\$output ${DSTDIR}doc $QUIET]], { output = v })\n end\nend\n\nloca"
    "l function install_headers()\n print \"[INSTALL]\\theaders\"\n execute[["
    "$CP ${SRCDIR}luaconf.h ${DSTDIR}include $QUIET]]\n execute[[$CP ${SRCDIR"
    "}lua.h ${DSTDIR}include $QUIET]]\n execute[[$CP ${SRCDIR}lua.hpp ${DSTDI"
    "R}include $QUIET]]\n execute[[$CP ${SRCDIR}lauxlib.h ${DSTDIR}include $Q"
    "UIET]]\n execute[[$CP ${SRCDIR}lualib.h ${DSTDIR}include $QUIET]]\nend\n"
    "\nlocal function install_executables()\n print \"[INSTALL]\\texecutables"
    "\"\n execute[[$CP lua.exe $DSTDIR $QUIET]]\n execute[[$CP luac.exe $DSTD"
    "IR $QUIET]]\n execute[[$CP lua$LUAV.exe $DSTDIR $QUIET]]\n execute[[$CP "
    "lua$LUAV.dll $DSTDIR $QUIET]]\n execute[[$RM vc*.pdb]]\n execute[[$CP *."
    "pdb $DSTDIR $QUIET]]\nend\n\nlocal function install_libraries()\n print "
    "\"[INSTALL]\\tlibraries\"\n execute[[$CP *.a ${DSTDIR}lib $QUIET]]\n exe"
    "cute[[$CP *.lib ${DSTDIR}lib $QUIET]]\n execute[[$CP *.def ${DSTDIR}lib "
    "$QUIET]]\n execute[[$CP *.exp ${DSTDIR}lib $QUIET]]\nend\n\nlocal functi"
    "on dist()\n assert = function(...) return ... end\n info.DSTDIR = expand"
    "[[Lua$LUAV$TOOLCHAIN\\]]\n print(\"[INSTALL]\\t\"..info.DSTDIR)\n make_d"
    "irs()\n install_doc()\n install_headers()\n install_executables()\n inst"
    "all_libraries()\nend\n\nlocal function cleanup()\n print(\"[CLEANUP]\")\n"
    " execute[[$RM *.def *.a *.exe *.dll *.rc *.o $QUIET]]\n execute[[$RM *.o"
    "bj *.lib *.exp *.res *.pdb *.ilk $QUIET]]\n execute[[$RM *.idb *.ipdb *."
    "iobj $QUIET]]\n execute[[$RM luaconf.h $QUIET]]\nend\n\n-- begin build\n"
    "while arg[1] and arg[1]:sub(1,1) == '-' do\n if arg[1] == '-v' then\n VE"
    "RBOSE = true\n elseif arg[1] == '-d' then\n DEBUG = true\n elseif arg[1]"
    " == '-h' or arg[1] == '-?' then\n print(arg[0]..\" [-v] [-d] [toolchain]"
    "\")\n print(\"support toolchain:\")\n local tls = {}\n for k,v in pairs("
    "info) do\n if type(v) == 'table' and v.base then\n tls[#tls+1] = k\n end"
    "\n end\n table.sort(tls)\n print(\" \"..table.concat(tls, \"\\n \"))\n r"
    "eturn\n end\n table.remove(arg, 1)\nend\n\nfind_version()\npatch_luaconf"
    "()\n\nfind_toolchain(arg[1])\nbuildone_luas()\nbuildone_luadll()\nbuild_"
    "lua()\nbuildone_luac()\nbuild_lualib()\ndist()\ncleanup()\nprint \"[DONE"
    "]\"\n\n-- cc: cc='D:\\lua53\\lua.exe'\n"
;

  return luaL_loadbuffer(L, buff, bufflen, "=luabuild.lua");
}


#endif /* luabuild_h */
