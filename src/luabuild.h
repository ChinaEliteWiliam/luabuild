/* this file is generated by gen_luabuild_h.lua, DO NOT MODIFY THIS! */
#ifndef luabuild_h
#define luabuild_h


#include <lua.h>
#include <lauxlib.h>


static int load_chunk(lua_State *L) {
  size_t bufflen = 12319;
  char buff[] = 
    "\nlocal USE_ONE = true\nlocal USE_VC = true\n\nlocal DEBUG = false\nloca"
    "l VERBOSE = false\nlocal info = {\n ROOT = [[..\\]];\n SRCDIR = [[..\\sr"
    "c\\]];\n DSTDIR = [[dstdir\\]];\n\n RM = 'del';\n CP = 'copy /y';\n QUIE"
    "T = ' >nul 2>nul';\n}\ninfo.gcc = {\n CC = 'gcc $CFLAGS $flags -c $input"
    "';\n LD = 'gcc $CFLAGS $flags -o $output $input $libs';\n AR = 'ar rcs $"
    "output $input';\n RC = 'windres -i $input -o $RCOUT';\n RCOUT = '${outpu"
    "t}.o';\n OBJ = '.o';\n}\ninfo.gcc_dbg = {\n base = info.gcc;\n CFLAGS = "
    "'-std=c99 -ggdb -pipe -O0 -Wall';\n}\ninfo.gcc_rel = {\n base = info.gcc"
    ";\n CFLAGS = '-std=c99 -s -pipe -O3 -Wall ';\n}\ninfo.vs = {\n CC = 'cl "
    "/nologo $CFLAGS $flags /c $input';\n LD = 'link /nologo $LDFLAGS $flags "
    "/OUT:\"$output\" $input $libs';\n AR = 'lib /nologo /OUT:$output $input'"
    ";\n RC = 'rc /nologo /Fo\"$RCOUT\" $input';\n RCOUT = '${output}.res';\n"
    " OBJ = '.obj';\n}\ninfo.vs_dbg = {\n base = info.vs;\n CFLAGS = '/W3 /D_"
    "CRT_SECURE_NO_DEPRECATE '..\n '/MTd /Zi /Ob0 /Od /RTC1 /D _DEBUG';\n LDF"
    "LAGS = '/DEBUG /INCREMENTAL:NO /PDB:\"$output.pdb\"';\n}\ninfo.vs_rel = "
    "{\n base = info.vs;\n CFLAGS = '/nologo /W3 /D_CRT_SECURE_NO_DEPRECATE '"
    "..\n '/MT /GS- /GL /Gy /Oy- /O2 /Oi /arch:SSE2 /DNDEBUG';\n LDFLAGS = '/"
    "OPT:REF /OPT:ICF /INCREMENTAL:NO /LTCG:incremental';\n}\ninfo.vs_rel_pdb"
    " = {\n base = info.vs;\n CFLAGS = '/nologo /W3 /D_CRT_SECURE_NO_DEPRECAT"
    "E '..\n '/MT /GS- /GL /Gy /Oy- /O2 /Oi /Zi /arch:SSE2 /DNDEBUG';\n LDFLA"
    "GS = '/OPT:REF /OPT:ICF /INCREMENTAL:NO /LTCG:incremental /DEBUG:FASTLIN"
    "K /PDB:\"$output.pdb\"';\n}\ninfo.vs_rel_min = {\n base = info.vs;\n CFL"
    "AGS = '/nologo /W3 /D_CRT_SECURE_NO_DEPRECATE '..\n '/MT /GS- /GL /Gy /O"
    "1 /Ob1 /Oi /Oy- /arch:SSE2 /DNDEBUG';\n LDFLAGS = '/OPT:REF /OPT:ICF /IN"
    "CREMENTAL:NO /LTCG:incremental';\n}\n\nlocal function find_version()\n l"
    "ocal LUA_VERSION_MAJOR\n local LUA_VERSION_MINOR\n local LUA_VERSION_REL"
    "EASE\n local LUA_COPYRIGHT\n local LUA_RELEASE\n\n io.input(info.SRCDIR "
    ".. \"lua.h\")\n for line in io.lines() do\n local v = line:match \"#defi"
    "ne%s+LUA_VERSION_MAJOR%s+\\\"(%d+)\\\"\"\n if v then LUA_VERSION_MAJOR ="
    " v goto next end\n local v = line:match \"#define%s+LUA_VERSION_MINOR%s+"
    "\\\"(%d+)\\\"\"\n if v then LUA_VERSION_MINOR = v goto next end\n local "
    "v = line:match \"#define%s+LUA_VERSION_RELEASE%s+\\\"(%d+)\\\"\"\n if v "
    "then LUA_VERSION_RELEASE = v goto next end\n local v = line:match \"#def"
    "ine%s+LUA_COPYRIGHT.-\\\"%s*(.-)\\\"\"\n if v then LUA_COPYRIGHT = v got"
    "o next end\n local v = line:match \"#define%s+LUA_RELEASE%s+\\\"(.-)\\\""
    "\"\n if v then LUA_RELEASE = tonumber(v) goto next end\n ::next::\n end\n"
    " io.input():close()\n io.input(io.stdin)\n\n if not LUA_VERSION_MAJOR th"
    "en\n assert(LUA_RELEASE, \"can not find Lua release!!\")\n LUA_VERSION_M"
    "AJOR,\n LUA_VERSION_MINOR,\n LUA_VERSION_RELEASE = LUA_RELEASE:match \"^"
    "Lua (%d+)%.(%d+)%.(%d+)\"\n assert(LUA_VERSION_MAJOR, \"can not find Lua"
    " release!!\")\n end\n print((\"find Lua release: Lua %d.%d.%d\\n%s\"):fo"
    "rmat(\n LUA_VERSION_MAJOR, LUA_VERSION_MINOR, LUA_VERSION_RELEASE,\n LUA"
    "_COPYRIGHT))\n info.LUA_VERSION_MAJOR = LUA_VERSION_MAJOR\n info.LUA_VER"
    "SION_MINOR = LUA_VERSION_MINOR\n info.LUA_VERSION_RELEASE = LUA_VERSION_"
    "RELEASE\n info.LUA_COPYRIGHT = LUA_COPYRIGHT\n info.LUAV = LUA_VERSION_M"
    "AJOR..LUA_VERSION_MINOR\n info.LUA_RELEASE = (\"%d.%d.%d\"):format(\n LU"
    "A_VERSION_MAJOR,\n LUA_VERSION_MINOR,\n LUA_VERSION_RELEASE)\nend\n\nloc"
    "al function expand(s, t)\n local count = 0\n local function replace(s, s"
    "pace)\n local s = t and t[s] or info[s]\n if s then\n if type(s) == \"ta"
    "ble\" then\n s = table.concat(s, \" \")\n end\n s = s .. (space or \"\")"
    "\n count = count + 1\n end\n return s or \"\"\n end\n assert(s, \"templa"
    "te expected\")\n while true do\n local old = count\n s = s:gsub(\"$%{([%"
    "w_]+)%}\", replace)\n s = s:gsub(\"$([%w_]+)(%s*)\", replace)\n if old ="
    "= count then return s end\n end\nend\n\nlocal function patch_rcfile(file"
    ")\n local info = {\n LUA_CSV_RELEASE = (\"%d,%d,%d,0\"):format(\n info.L"
    "UA_VERSION_MAJOR,\n info.LUA_VERSION_MINOR,\n info.LUA_VERSION_RELEASE);"
    "\n }\n\n print(\"[PATCH]\\t\"..file..\".rc\")\n io.input(\"res/\"..file."
    ".\".rc\")\n io.output(file..\".rc\")\n\n for line in io.lines() do\n io."
    "write(expand(line, info), \"\\n\")\n end\n\n io.input():close()\n io.out"
    "put():close()\n io.input(io.stdin)\n io.output(io.stdout)\nend\n\nlocal "
    "function patch_luaconf()\n local LUA_VDIR = info.LUA_VERSION_MAJOR..\".\""
    "..info.LUA_VERSION_MINOR\n local t = {\n path = [[\n#define LUA_PATH_DEF"
    "AULT \".\\\\?.lua;\" \".\\\\?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"?.lua;\""
    " LUA_CDIR \"?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"lua\\\\?.lua;\" LUA_CDIR"
    " \"lua\\\\?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"clibs\\\\?.lua;\" LUA_CDIR"
    " \"clibs\\\\?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"..\\\\share\\\\lua\\\\]]"
    "..LUA_VDIR..[[\\\\?.lua;\" \\\n\t\tLUA_CDIR \"..\\\\share\\\\lua\\\\]].."
    "LUA_VDIR..[[\\\\?\\\\init.lua\"]];\n cpath = [[\n#define LUA_CPATH_DEFAU"
    "LT \".\\\\?.dll;\" \".\\\\loadall.dll;\" \\\n\t\tLUA_CDIR \"?.dll;\" LUA"
    "_CDIR \"loadall.dll;\" \\\n\t\tLUA_CDIR \"clibs\\\\?.dll;\" LUA_CDIR \"c"
    "libs\\\\loadall.dll;\" \\\n\t\tLUA_CDIR \"..\\\\lib\\\\lua\\\\]]..LUA_VD"
    "IR..[[\\\\?.dll;\" \\\n\t\tLUA_CDIR \"..\\\\lib\\\\lua\\\\]]..LUA_VDIR.."
    "[[\\\\loadall.dll\"]];\n }\n\n print(\"[PATCH]\\tluaconf.h\")\n io.input"
    "(info.SRCDIR..\"luaconf.h\")\n io.output \"luaconf.h\"\n local patched ="
    " 0\n local begin\n for line in io.lines() do\n if patched < 2 then\n if "
    "begin and not line:match \"\\\\$\" then\n line = t[begin]\n patched = pa"
    "tched + 1\n begin = nil\n elseif line:match \"#define%s+LUA_PATH_DEFAULT"
    "\" then\n begin = \"path\"\n elseif line:match \"#define%s+LUA_CPATH_DEF"
    "AULT\" then\n begin = \"cpath\"\n end\n end\n\n if not begin then io.wri"
    "te(line, \"\\n\") end\n end\n io.input():close()\n io.output():close()\n"
    " io.input(io.stdin)\n io.output(io.stdout)\nend\n\nlocal function glob(p"
    "attern)\n local fh = assert(io.popen(\"DIR /B /W \"..pattern))\n local f"
    "iles = {}\n for line in fh:lines() do\n files[#files+1] = line\n end\n f"
    "h:close()\n return files\nend\n\nlocal function map(files, f)\n local t "
    "= {}\n for i, v in ipairs(files) do\n local new = f(i, v)\n if new then "
    "t[#t+1] = new end\n end\n return t\nend\n\nlocal function tsub(files, pa"
    "ttern, replace)\n local t = {}\n for i, v in ipairs(files) do\n t[i] = v"
    ":gsub(pattern, replace)\n end\n return t\nend\n\nlocal function execute("
    "fmt, t)\n local cmdline = expand(fmt, t)\n if VERBOSE then\n print(\">>\""
    ", cmdline)\n end\n return assert(os.execute(cmdline))\nend\n\nlocal func"
    "tion find_toolchain(toolchain)\n if not toolchain then\n --local env = o"
    "s.getenv \"VS120COMNTOOLS\" or -- VS2013\n --os.getenv \"VS110COMNTOOLS\""
    " or -- VS2012\n --os.getenv \"VS100COMNTOOLS\" or -- VS2010\n --os.geten"
    "v \"VS90COMNTOOLS\" -- VS2008\n --if env then\n --execute(\"call \"..env"
    "..\"vsvars32.bat\")\n --end\n if os.execute(expand[[cl $QUIET]]) then\n "
    "print(\"find VS toolchain\")\n toolchain = \"vs\"\n elseif os.execute(ex"
    "pand[[gcc --version $QUIET]]) then\n print(\"find GCC toolchain\")\n too"
    "lchain = \"gcc\"\n end\n if not toolchain then\n print(\"can not find to"
    "olchain!!!\")\n end\n toolchain = toolchain .. (DEBUG and \"_dbg\" or \""
    "_rel\")\n end\n print(\"use toolchain: \"..toolchain)\n info.TOOLCHAIN ="
    " toolchain\n local t = info[toolchain]\n repeat\n for k,v in pairs(t) do"
    "\n info[k] = v\n end\n t = t.base\n until not t\nend\n\nlocal function c"
    "ompile(file, flags)\n if type(file) == \"string\" then\n print(\"[CC]\\t"
    "\"..file)\n end\n return execute(\"$CC\", {\n input = file,\n flags = fl"
    "ags,\n })\nend\n\nlocal function compile_rc(file)\n print(\"[RC]\\t\"..f"
    "ile)\n local t = {\n input = file,\n output = file,\n }\n if execute(inf"
    "o.RC, t) then\n return expand(info.RCOUT, t)\n end\nend\n\nlocal functio"
    "n link(target, files, flags, libs)\n print(\"[LINK]\\t\"..target)\n retu"
    "rn execute(info.LD, {\n flags = flags,\n input = files,\n output = targe"
    "t,\n libs = libs,\n })\nend\n\nlocal function library(lib, files)\n prin"
    "t(\"[AR]\\t\"..lib)\n return execute(info.AR, {\n output = lib,\n input "
    "= files,\n })\nend\n\nlocal function buildone_luas()\n patch_rcfile \"lu"
    "as\"\n local LUAV = info.LUAV\n local rc = compile_rc \"luas.rc\"\n loca"
    "l flags = { \"-DLUA_BUILD_AS_DLL -DMAKE_LUA -I$SRCDIR\" }\n local ldflag"
    "s = {}\n if tonumber(LUAV) >= 53 then\n flags[#flags+1] = \"-DHAVE_LPREF"
    "IX\"\n end\n if info.TOOLCHAIN:match \"^gcc\" then\n ldflags[#ldflags+1]"
    " = \"-Wl,--out-implib,liblua\"..LUAV..\".exe.a\"\n end\n compile(\"one.c"
    "\", flags)\n link(\"lua\"..LUAV..\".exe\", \"one$OBJ \"..rc, ldflags)\n "
    "if info.TOOLCHAIN:match \"^vs\" then\n execute[[move /Y lua${LUAV}.lib l"
    "ua${LUAV}exe.lib $QUIET]]\n execute[[move /Y lua${LUAV}.exp lua${LUAV}ex"
    "e.exp $QUIET]]\n end\nend\n\nlocal function buildone_luadll()\n patch_rc"
    "file \"luadll\"\n local LUAV = info.LUAV\n local rc = compile_rc \"luadl"
    "l.rc\"\n local flags = { \"-DLUA_BUILD_AS_DLL -DMAKE_LIB -I$SRCDIR\" }\n"
    " local ldflags = {}\n if tonumber(LUAV) >= 53 then\n flags[#flags+1] = \""
    "-DHAVE_LPREFIX\"\n end\n if info.TOOLCHAIN:match \"^gcc\" then\n ldflags"
    "[#ldflags+1] = \"-mdll\"\n ldflags[#ldflags+1] = \"-Wl,--out-implib,libl"
    "ua\"..LUAV..\".dll.a\"\n ldflags[#ldflags+1] = \"-Wl,--output-def,lua\"."
    ".LUAV..\".def\"\n else\n ldflags[#ldflags+1] = \"/DLL\"\n end\n compile("
    "\"one.c \", flags)\n link(\"lua\"..LUAV..\".dll\", \"one$OBJ \"..rc, ldf"
    "lags)\nend\n\nlocal function build_lua()\n patch_rcfile \"lua\"\n local "
    "LUAV = info.LUAV\n local rc = compile_rc \"lua.rc\"\n local flags = \"-D"
    "LUA_BUILD_AS_DLL -I$SRCDIR\"\n local libs\n if info.TOOLCHAIN:match \"^g"
    "cc\" then\n libs = \"-L. -llua\"..LUAV..\".dll\"\n else\n libs = \"lua\""
    "..LUAV..\".lib\"\n end\n compile(\"lua.c \", flags)\n link(\"lua.exe\", "
    "\"lua$OBJ \"..rc, nil, libs)\nend\n\nlocal function buildone_luac()\n pa"
    "tch_rcfile \"luac\"\n local LUAV = info.LUAV\n local rc = compile_rc \"l"
    "uac.rc\"\n local flags = \"-DMAKE_LUAC -I$SRCDIR\"\n if tonumber(LUAV) >"
    "= 53 then\n flags = flags .. \" -DHAVE_LPREFIX\"\n end\n compile(\"one.c"
    " \", flags)\n link(\"luac.exe\", \"one$OBJ \"..rc)\nend\n\nlocal functio"
    "n build_lualib()\n print(\"[CC]\\tlualib\")\n local files = map(glob(inf"
    "o.SRCDIR..\"*.c\"), function(i, v)\n if v ~= \"lua.c\" and v ~= \"luac.c"
    "\" then\n return info.SRCDIR .. v\n end\n end)\n local LUAV = info.LUAV\n"
    " compile(files, \"-DLUA_BUILD_AS_DLL -I$SRCDIR\")\n if info.TOOLCHAIN:ma"
    "tch \"^gcc\" then\n library(\"liblua\"..LUAV..\".a\",\n tsub(files, info"
    ".SRCDIR..\"(.*).c$\", \"%1.o\"))\n else\n library(\"lua\"..LUAV..\"s.lib"
    "\",\n tsub(files, info.SRCDIR..\"(.*).c$\", \"%1.obj\"))\n end\n execute"
    "(\"$RM /s /q *.o *.obj $QUIET\")\nend\n\nlocal function make_dirs()\n pr"
    "int(\"[MKDIR]\\t\"..info.DSTDIR)\n execute [[del /s /q $DSTDIR $QUIET]]\n"
    " execute [[mkdir ${DSTDIR} $QUIET]]\n execute [[mkdir ${DSTDIR}clibs $QU"
    "IET]]\n execute [[mkdir ${DSTDIR}doc $QUIET]]\n execute [[mkdir ${DSTDIR"
    "}lua $QUIET]]\n execute [[mkdir ${DSTDIR}include $QUIET]]\n execute [[mk"
    "dir ${DSTDIR}lib $QUIET]]\nend\n\nlocal function install_doc()\n print(\""
    "[INSTALL]\\tdocuments\")\n for i, v in ipairs(glob(info.ROOT..\"doc\")) "
    "do\n execute([[$CP ${ROOT}doc\\$output ${DSTDIR}doc $QUIET]], { output ="
    " v })\n end\nend\n\nlocal function install_headers()\n print \"[INSTALL]"
    "\\theaders\"\n execute[[$CP ${SRCDIR}luaconf.h ${DSTDIR}include $QUIET]]"
    "\n execute[[$CP ${SRCDIR}lua.h ${DSTDIR}include $QUIET]]\n execute[[$CP "
    "${SRCDIR}lua.hpp ${DSTDIR}include $QUIET]]\n execute[[$CP ${SRCDIR}lauxl"
    "ib.h ${DSTDIR}include $QUIET]]\n execute[[$CP ${SRCDIR}lualib.h ${DSTDIR"
    "}include $QUIET]]\nend\n\nlocal function install_executables()\n print \""
    "[INSTALL]\\texecutables\"\n execute[[$CP lua.exe $DSTDIR $QUIET]]\n exec"
    "ute[[$CP luac.exe $DSTDIR $QUIET]]\n execute[[$CP lua$LUAV.exe $DSTDIR $"
    "QUIET]]\n execute[[$CP lua$LUAV.dll $DSTDIR $QUIET]]\n execute[[$RM vc*."
    "pdb]]\n execute[[$CP *.pdb $DSTDIR $QUIET]]\nend\n\nlocal function insta"
    "ll_libraries()\n print \"[INSTALL]\\tlibraries\"\n execute[[$CP *.a ${DS"
    "TDIR}lib $QUIET]]\n execute[[$CP *.lib ${DSTDIR}lib $QUIET]]\n execute[["
    "$CP *.def ${DSTDIR}lib $QUIET]]\n execute[[$CP *.exp ${DSTDIR}lib $QUIET"
    "]]\nend\n\nlocal function dist()\n assert = function(...) return ... end"
    "\n info.DSTDIR = expand[[Lua$LUAV$TOOLCHAIN\\]]\n print(\"[INSTALL]\\t\""
    "..info.DSTDIR)\n make_dirs()\n install_doc()\n install_headers()\n insta"
    "ll_executables()\n install_libraries()\nend\n\nlocal function cleanup()\n"
    " print(\"[CLEANUP]\")\n execute[[$RM *.def *.a *.exe *.dll *.rc *.o $QUI"
    "ET]]\n execute[[$RM *.obj *.lib *.exp *.res *.pdb *.ilk $QUIET]]\n execu"
    "te[[$RM *.idb *.ipdb *.iobj $QUIET]]\n execute[[$RM luaconf.h $QUIET]]\n"
    "end\n\n-- begin build\nwhile arg[1] and arg[1]:sub(1,1) == '-' do\n if a"
    "rg[1] == '-v' then\n VERBOSE = true\n elseif arg[1] == '-d' then\n DEBUG"
    " = true\n elseif arg[1] == '-h' or arg[1] == '-?' then\n print(arg[0]..\""
    " [-v] [-d] [toolchain]\")\n print(\"support toolchain:\")\n local tls = "
    "{}\n for k,v in pairs(info) do\n if type(v) == 'table' and v.base then\n"
    " tls[#tls+1] = k\n end\n end\n table.sort(tls)\n print(\" \"..table.conc"
    "at(tls, \"\\n \"))\n return\n end\n table.remove(arg, 1)\nend\n\nfind_ve"
    "rsion()\npatch_luaconf()\n\nfind_toolchain(arg[1])\nbuildone_luas()\nbui"
    "ldone_luadll()\nbuild_lua()\nbuildone_luac()\nbuild_lualib()\ndist()\ncl"
    "eanup()\nprint \"[DONE]\"\n\n-- cc: cc='D:\\lua53\\lua.exe'\n"
;

  return luaL_loadbuffer(L, buff, bufflen, "=luabuild.lua");
}


#endif /* luabuild_h */
